<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[directx初第三卷]]></title>
      <url>2324268086.github.io/2017/01/30/directx%E5%88%9D%E7%AC%AC%E4%B8%89%E5%8D%B7/</url>
      <content type="html"><![CDATA[<h3 id="固定功能渲染流水线"><a href="#固定功能渲染流水线" class="headerlink" title="固定功能渲染流水线"></a>固定功能渲染流水线</h3><p>顶点处理：非T&amp;L顶点（未经过坐标变换和光照处理的顶点）-&gt;[第一阶段]坐标变换和光照处理（世界变换-&gt;取景变换-&gt;光照处理-&gt;投影变换-&gt;视口变换）<br>光栅化计算：T&amp;L顶点（经过坐标变换和光照处理的顶点）-&gt;[第二阶段]光栅化处理（纹理映射-&gt;图元处理-&gt;内部函数改变渲染状态）<br>像素处理：片段处理器-&gt;显存帧缓冲-&gt;显示</p>
<h3 id="可编程渲染流水线"><a href="#可编程渲染流水线" class="headerlink" title="可编程渲染流水线"></a>可编程渲染流水线</h3><p>镶嵌处理：顶点-&gt;镶嵌器<br>顶点处理：变换与光照+顶点着色器-&gt;剔除（背面剔除）-&gt;剪裁（用户剪裁平面-&gt;截头体剪裁）-&gt;齐次除法-&gt;视口映射<br>光栅化计算：三角形设置<br>像素处理：多重纹理贴图+像素着色器-&gt;测试（剪裁测试-&gt;Alpha测试-&gt;深度测试+模版测试）-&gt;Alpha混合-&gt;浓淡处理-&gt;通道掩码-&gt;显存帧缓冲-&gt;显示</p>
<p>其中，顶点着色器模块，像素着色器模块为可编程模块<br>他们的着色器单元（四元组结构）分别为：<br>Vertex Shader：float4(X,Y,Z,W)<br>Pixel Shader：float4(R,G,B,A)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[directx初第二卷]]></title>
      <url>2324268086.github.io/2017/01/29/directx%E5%88%9D%E7%AC%AC%E4%BA%8C%E5%8D%B7/</url>
      <content type="html"><![CDATA[<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>添加头文件<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;d3dx9.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>声明变量<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LPDIRECT3D9 g_pD3D = <span class="literal">NULL</span>;</span><br><span class="line">LPDIRECT3DDEVICE9 g_pd3dDevice = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<p>关键代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建directx接口</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == (g_pD3D = Direct3DCreate9(D3D_SDK_VERSION)))</span><br><span class="line">	<span class="keyword">return</span> E_FAIL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//校验硬件顶点运算</span></span><br><span class="line">D3DCAPS9 caps; <span class="keyword">int</span> vp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (FAILED(g_pD3D-&gt;GetDeviceCaps(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, &amp;caps)))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> E_FAIL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (caps.DevCaps &amp; D3DDEVCAPS_HWTRANSFORMANDLIGHT)</span><br><span class="line">	vp = D3DCREATE_HARDWARE_VERTEXPROCESSING; <span class="comment">//支持硬件顶点运算</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	vp = D3DCREATE_SOFTWARE_VERTEXPROCESSING; <span class="comment">//不支持硬件顶点运算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//填充D3DPRESENT_PARAMETER结构</span></span><br><span class="line">D3DPRESENT_PARAMETERS d3dpp;</span><br><span class="line">ZeroMemory(&amp;d3dpp, <span class="keyword">sizeof</span>(d3dpp));</span><br><span class="line">d3dpp.Windowed = TRUE; <span class="comment">//指定以Windows窗体形式显示</span></span><br><span class="line">d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD; <span class="comment">//当前屏幕绘制后它将自动从内存中删除  </span></span><br><span class="line">d3dpp.BackBufferFormat = D3DFMT_UNKNOWN; <span class="comment">//后台缓冲区像素格式为当前使用的显卡的像素格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建directx设备接口</span></span><br><span class="line"><span class="keyword">if</span> (FAILED(g_pD3D-&gt;CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWnd,</span><br><span class="line">	vp,</span><br><span class="line">	&amp;d3dpp, &amp;g_pd3dDevice)))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> E_FAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>关键代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> != g_pd3dDevice)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//清空缓存</span></span><br><span class="line">	g_pd3dDevice-&gt;Clear(<span class="number">0</span>, <span class="literal">NULL</span>, D3DCLEAR_TARGET, D3DCOLOR_XRGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1.0f</span>, <span class="number">0</span>); <span class="comment">//清空后台缓冲区</span></span><br><span class="line">	<span class="comment">//开始绘制</span></span><br><span class="line">	<span class="keyword">if</span> (SUCCEEDED(g_pd3dDevice-&gt;BeginScene()))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//绘制</span></span><br><span class="line">		....</span><br><span class="line">		<span class="comment">//结束绘制</span></span><br><span class="line">		g_pd3dDevice-&gt;EndScene();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//翻转显示</span></span><br><span class="line">	g_pd3dDevice-&gt;Present(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//后台渲染的东西翻转到前台</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[directx初第一卷]]></title>
      <url>2324268086.github.io/2017/01/29/directx%E5%88%9D%E7%AC%AC%E4%B8%80%E5%8D%B7/</url>
      <content type="html"><![CDATA[<h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>下载Directx SDK(directx sdk june10就可以了)，在VS(vs2013差不多了)中新建win32空项目，<br>然后在视图-&gt;属性管理器找到 Debug|Win32-&gt;Microsoft.Cpp.Win32.user，<br>双击，选择vc++目录，设置包含目录和库目录为刚刚下的directx sdk目录中include，lib\x86 的路径<br><a id="more"></a><br>选择链接器，设置附加依赖项，粘贴以下代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dxerr.lib</span><br><span class="line">dxguid.lib</span><br><span class="line">d3dx9d.lib</span><br><span class="line">d3dx10d.lib</span><br><span class="line">d3d9.lib</span><br><span class="line">winmm.lib</span><br><span class="line">comctl32.lib</span><br></pre></td></tr></table></figure></p>
<p>下载番茄插件(VA)，同样加入dx sdk的include路径</p>
<p>配置完成了! 不在累赘</p>
<h3 id="Directx渲染体系"><a href="#Directx渲染体系" class="headerlink" title="Directx渲染体系"></a>Directx渲染体系</h3><p>老版：固定功能流水线 使用directx内部封装的函数改变渲染状态<br>新版：可编程渲染流水线 shader，使用hlsl(支持cg函数)或者shader汇编代码(被hlsl代替)来灵活的渲染</p>
<h3 id="Directx程序流程"><a href="#Directx程序流程" class="headerlink" title="Directx程序流程"></a>Directx程序流程</h3><p>创建win32窗口-&gt;初始化（创建directx接口-&gt;校验硬件顶点运算-&gt;填充D3DPRESENT_PARAMETER结构-&gt;创建directx设备接口）<br>中间-&gt;场景布置<br>win32消息循环-&gt;渲染（清空缓存-&gt;开始绘制-&gt;绘制-&gt;结束绘制-&gt;翻转显示）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[directx数学基础2]]></title>
      <url>2324268086.github.io/2017/01/28/directx%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%802/</url>
      <content type="html"><![CDATA[<ol>
<li>向量（vector）：在游戏中通常表示位置，移位，方向，速度和作用力（请看directx数学基础1）</li>
<li>矩阵（matrix）：在游戏中提供高效的变换方式，几何变换与坐标变换</li>
</ol>
<h2 id="矩阵（矩形实数数组）"><a href="#矩阵（矩形实数数组）" class="headerlink" title="矩阵（矩形实数数组）"></a>矩阵（矩形实数数组）</h2><a id="more"></a>
<h3 id="矩阵乘法（a中的行向量的维数必须与b中的列向量的维数相同）"><a href="#矩阵乘法（a中的行向量的维数必须与b中的列向量的维数相同）" class="headerlink" title="矩阵乘法（a中的行向量的维数必须与b中的列向量的维数相同）"></a>矩阵乘法（a中的行向量的维数必须与b中的列向量的维数相同）</h3><p>例如： <img src="/img/directx数学基础_13.png" alt=""></p>
<h3 id="转置矩阵（transpose：-对一个矩阵的行和列进行互换）"><a href="#转置矩阵（transpose：-对一个矩阵的行和列进行互换）" class="headerlink" title="转置矩阵（transpose： 对一个矩阵的行和列进行互换）"></a>转置矩阵（transpose： 对一个矩阵的行和列进行互换）</h3><p>标记为T</p>
<h3 id="单位矩阵（identity：-除了对角线上的元素为1外，其他元素均为0）"><a href="#单位矩阵（identity：-除了对角线上的元素为1外，其他元素均为0）" class="headerlink" title="单位矩阵（identity： 除了对角线上的元素为1外，其他元素均为0）"></a>单位矩阵（identity： 除了对角线上的元素为1外，其他元素均为0）</h3><p>单位矩阵相当于1 <img src="/img/directx数学基础_14.png" alt=""></p>
<h3 id="逆矩阵（inverse：-乘法的逆运算（矩阵除法运算））"><a href="#逆矩阵（inverse：-乘法的逆运算（矩阵除法运算））" class="headerlink" title="逆矩阵（inverse： 乘法的逆运算（矩阵除法运算））"></a>逆矩阵（inverse： 乘法的逆运算（矩阵除法运算））</h3><p>性质： <img src="/img/directx数学基础_15.png" alt=""></p>
<h3 id="基本变换（4x4矩阵与向量-矩阵乘积来描述变换）"><a href="#基本变换（4x4矩阵与向量-矩阵乘积来描述变换）" class="headerlink" title="基本变换（4x4矩阵与向量-矩阵乘积来描述变换）"></a>基本变换（4x4矩阵与向量-矩阵乘积来描述变换）</h3><p>齐次坐标(homogeneous coordinate)： 用于表示3D向量或点的四元组<br>通过它的第4个坐标分量w（控制平移）来判断：<br><img src="/img/directx数学基础_16.png" alt=""></p>
<h4 id="缩放："><a href="#缩放：" class="headerlink" title="缩放："></a>缩放：</h4><p><img src="/img/directx数学基础_17.png" alt=""> <img src="/img/directx数学基础_18.png" alt=""><br>例子：<br>假设我们通过一个最小点(−4,−4,0)和一个最大点(4,4,0)来定义一个正方形，我们希望<br>将正方形沿 x 轴缩小 0.5 倍，沿 y 轴放大 2.0 倍，z 轴保持不变则对应的缩放矩阵为：<br><img src="/img/directx数学基础_19.png" alt=""><br>再对正方形进行缩放（变换），将正方形的两个点与该矩阵相乘<br><img src="/img/directx数学基础_20.png" alt=""><br>结果<br><img src="/img/directx数学基础_21.png" alt=""></p>
<h4 id="旋转："><a href="#旋转：" class="headerlink" title="旋转："></a>旋转：</h4><p>绕n（x,y,z）轴旋转的’万能’旋转矩阵<br><img src="/img/directx数学基础_22.png" alt=""></p>
<p>正交矩阵(orthogonal matrix): 行向量都是相互垂直且为单位长度<br>性质：<br>它的逆矩阵与它的转置矩阵相等 <img src="/img/directx数学基础_23.png" alt=""></p>
<p>绕x，y，z轴（n=（1,0,0） n=（0,1,0） n=（0,0,1））旋转的矩阵<br><img src="/img/directx数学基础_24.png" alt=""></p>
<p>例子：<br>假设我们通过一个最小点(−1,0,−1)和一个最大点(1,0,1)来定义一个正方形。让正方形<br>绕着 y 轴的顺时针方向旋转−30º（即，逆时针方向旋转 30º）。则y轴旋转矩阵为：<br><img src="/img/directx数学基础_25.png" alt=""><br>再对正方形进行旋转（变换），将正方形的两个点与该矩阵相乘：<br><img src="/img/directx数学基础_26.png" alt=""><br>结果<br><img src="/img/directx数学基础_27.png" alt=""></p>
<h4 id="平移："><a href="#平移：" class="headerlink" title="平移："></a>平移：</h4><p><img src="/img/directx数学基础_28.png" alt=""><br>平移矩阵的逆矩阵如下：<br><img src="/img/directx数学基础_29.png" alt=""><br>例子：<br>假设我们通过一个最小点(−8,2,0)和一个最大点(−2,8,0)来定义一个正方形。让正方形<br>沿x轴平移12，沿y轴平移−10，z轴保持不变。则对应的平移矩阵如下：<br><img src="/img/directx数学基础_30.png" alt=""><br>再对正方形进行平移（变换），将正方形的两个点与该矩阵相乘：<br><img src="/img/directx数学基础_31.png" alt=""><br>结果<br><img src="/img/directx数学基础_32.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[directx数学基础1]]></title>
      <url>2324268086.github.io/2017/01/28/directx%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<ol>
<li>向量（vector）：在游戏中通常表示位置，移位，方向，速度和作用力</li>
<li>矩阵（matrix）：在游戏中提供高效的变换方式，几何变换与坐标变换（请看directx数学基础2）</li>
</ol>
<h2 id="向量（同具有大小和方向的物理量）"><a href="#向量（同具有大小和方向的物理量）" class="headerlink" title="向量（同具有大小和方向的物理量）"></a>向量（同具有大小和方向的物理量）</h2><a id="more"></a>
<h3 id="坐标系（directx为左手坐标系）"><a href="#坐标系（directx为左手坐标系）" class="headerlink" title="坐标系（directx为左手坐标系）"></a>坐标系（directx为左手坐标系）</h3><p><img src="/img/directx数学基础_1.png" alt=""><br>看上去就像图中z向量相反</p>
<h3 id="向量长度（length）"><a href="#向量长度（length）" class="headerlink" title="向量长度（length）"></a>向量长度（length）</h3><p>几何学： 有向线段的长度<br><img src="/img/directx数学基础_2.png" alt=""></p>
<p>代数方式： 毕达哥拉斯定理（’不规则’勾股定理）<br><img src="/img/directx数学基础_3.png" alt=""></p>
<h3 id="单位向量（normalize：-不关心向量的长度，只希望用向量来表示一个单纯的方向）"><a href="#单位向量（normalize：-不关心向量的长度，只希望用向量来表示一个单纯的方向）" class="headerlink" title="单位向量（normalize： 不关心向量的长度，只希望用向量来表示一个单纯的方向）"></a>单位向量（normalize： 不关心向量的长度，只希望用向量来表示一个单纯的方向）</h3><p>进行规范化处理： <img src="/img/directx数学基础_4.png" alt=""></p>
<p>验证是否为单位向量？只要计算单位向量u的长度就行<br><img src="/img/directx数学基础_5.png" alt=""></p>
<h3 id="点积（dot：-两个向量对应分量的乘积之和）"><a href="#点积（dot：-两个向量对应分量的乘积之和）" class="headerlink" title="点积（dot： 两个向量对应分量的乘积之和）"></a>点积（dot： 两个向量对应分量的乘积之和）</h3><p>代数方式： <img src="/img/directx数学基础_6.png" alt=""></p>
<p>余弦定理： <img src="/img/directx数学基础_7.png" alt=""><br>结果代入cosx的反函数（acos）即可算出度数，</p>
<p>例如： <img src="/img/directx数学基础_9.png" alt=""></p>
<p>几何性质：<br><img src="/img/directx数学基础_8.png" alt=""></p>
<h3 id="叉积（cross：-两个3D向量计算叉积，得到垂直于两个向量的第3个向量-）"><a href="#叉积（cross：-两个3D向量计算叉积，得到垂直于两个向量的第3个向量-）" class="headerlink" title="叉积（cross： 两个3D向量计算叉积，得到垂直于两个向量的第3个向量 ）"></a>叉积（cross： 两个3D向量计算叉积，得到垂直于两个向量的第3个向量 ）</h3><p>代数方式： <img src="/img/directx数学基础_10.png" alt=""><br>例如： <img src="/img/directx数学基础_11.png" alt=""></p>
<p>正弦定理： <img src="/img/directx数学基础_12.png" alt=""><br>同理结果代入asin即可算出度数，</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[directx前言]]></title>
      <url>2324268086.github.io/2017/01/28/directx%E5%89%8D%E8%A8%80/</url>
      <content type="html"><![CDATA[<h4 id="说在前面的话"><a href="#说在前面的话" class="headerlink" title="说在前面的话"></a>说在前面的话</h4><h3 id="为什么学directx？"><a href="#为什么学directx？" class="headerlink" title="为什么学directx？"></a>为什么学directx？</h3><p>原因很简单：对游戏开发的热爱，是游戏开发者必学的一门功课<br><a id="more"></a></p>
<h3 id="为什么选择directx？"><a href="#为什么选择directx？" class="headerlink" title="为什么选择directx？"></a>为什么选择directx？</h3><p>跟directx相比有opengl，还有gdi等，虽然directx不支持跨平台，<br>但是实际开发或者个人游戏也好，用unity之类的引擎解决就好，<br>directx其他方面还是远超opengl，文档也很多。至于gdi，，gdi的<br>性能就是很大的瓶颈，directx直接基于com的效率高的不要不要<br>的，这也是为什么大多游戏引擎都是基于directx或opengl（特例）的</p>
<h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><p>龙书d9 d10 d11（只有英文版）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>2324268086.github.io/2017/01/26/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to the xiaojian of the home page</p>
<h2 id="欢迎来到小贱的主页"><a href="#欢迎来到小贱的主页" class="headerlink" title="欢迎来到小贱的主页"></a>欢迎来到小贱的主页</h2>]]></content>
    </entry>
    
  
  
</search>
