<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[directx初第九卷]]></title>
      <url>https://2324268086.github.io/2017/02/01/directx%E5%88%9D%E7%AC%AC%E4%B9%9D%E5%8D%B7/</url>
      <content type="html"><![CDATA[<h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><h3 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h3><a id="more"></a>
<p>声明变量<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">IDirect3DTexture9* texture = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>创建纹理贴图<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取纹理图片（设备指针，纹理图片地址，把结果存到贴图指针）</span></span><br><span class="line">D3DXCreateTextureFromFile(g_pd3dDevice, <span class="string">"UnityPlayerIcon.png"</span>, &amp;texture);</span><br><span class="line"><span class="comment">//读取纹理图片（设备指针，纹理图片地址，使用贴图宽度，使用贴图高度，渐进纹理级数，标志，纹理格式，</span></span><br><span class="line"><span class="comment">//保存纹理方式，纹理过滤方式，生成纹理序列的过滤方式，替换alpha值的颜色值，通常为null，调色板地址，把结果存到贴图指针）</span></span><br><span class="line">D3DXCreateTextureFromFileEx(g_pd3dDevice, <span class="string">"UnityPlayerIcon.png"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, D3DFMT_X8R8G8B8,</span><br><span class="line">D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, <span class="number">0xFF000000</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;texture);</span><br></pre></td></tr></table></figure></p>
<p>设置纹理贴图<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置贴图（应用到纹理第一层，贴图指针）</span></span><br><span class="line">g_pd3dDevice-&gt;SetTexture(<span class="number">0</span>, texture);</span><br></pre></td></tr></table></figure></p>
<h3 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h3><p><code>最近采样点纹理过滤</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g_pd3dDevice-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_MAGFILTER, D3DTEXF_POINT);</span><br><span class="line">g_pd3dDevice-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_MINFILTER, D3DTEXF_POINT);</span><br></pre></td></tr></table></figure></p>
<p><code>线性纹理过滤</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g_pd3dDevice-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);</span><br><span class="line">g_pd3dDevice-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);</span><br></pre></td></tr></table></figure></p>
<p><code>各向异性纹理过滤</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g_pd3dDevice-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_MAXANISOTROPY, <span class="number">3</span>);</span><br><span class="line">g_pd3dDevice-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_MAGFILTER, D3DTEXF_ANISOTROPIC);</span><br><span class="line">g_pd3dDevice-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_MINFILTER, D3DTEXF_ANISOTROPIC);</span><br></pre></td></tr></table></figure></p>
<p><code>多级渐进纹理过滤</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g_pd3dDevice-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR);</span><br><span class="line">g_pd3dDevice-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_MAXMIPLEVEL, <span class="number">16</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="纹理寻址"><a href="#纹理寻址" class="headerlink" title="纹理寻址"></a>纹理寻址</h3><p><code>重复纹理寻址</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g_pd3dDevice-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);</span><br><span class="line">g_pd3dDevice-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);</span><br></pre></td></tr></table></figure></p>
<p><code>镜像纹理寻址</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g_pd3dDevice-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_ADDRESSU, D3DTADDRESS_MIRROR);</span><br><span class="line">g_pd3dDevice-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_ADDRESSV, D3DTADDRESS_MIRROR);</span><br></pre></td></tr></table></figure></p>
<p><code>夹取纹理寻址</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g_pd3dDevice-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_ADDRESSU, D3DTADDRESS_CLAMP);</span><br><span class="line">g_pd3dDevice-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_ADDRESSV, D3DTADDRESS_CLAMP);</span><br></pre></td></tr></table></figure></p>
<p><code>边框纹理寻址</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g_pd3dDevice-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_ADDRESSU, D3DTADDRESS_BORDER);</span><br><span class="line">g_pd3dDevice-&gt;SetSamplerState(<span class="number">0</span>, D3DSAMP_ADDRESSV, D3DTADDRESS_BORDER);</span><br></pre></td></tr></table></figure></p>
<h3 id="纹理寻址没有效果？"><a href="#纹理寻址没有效果？" class="headerlink" title="纹理寻址没有效果？"></a>纹理寻址没有效果？</h3><p>定义顶点缓存的uv<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> VERTEX</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">float</span> _x, _y, _z;               </span><br><span class="line">	<span class="keyword">float</span> _u, _v; <span class="comment">// 纹理坐标</span></span><br><span class="line">	VERTEX(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z, <span class="keyword">float</span> u, <span class="keyword">float</span> v) : _x(x), _y(y), _z(z), _u(u), _v(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D3DFVF_VERTEX (D3DFVF_XYZ | D3DFVF_TEX1)</span></span><br></pre></td></tr></table></figure></p>
<p>填充<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v[<span class="number">0</span>] = VERTEX(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">v[<span class="number">1</span>] = VERTEX(<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">v[<span class="number">2</span>] = VERTEX(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2.0f</span>, <span class="number">2.0f</span>);</span><br><span class="line">v[<span class="number">3</span>] = VERTEX(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0.0f</span>, <span class="number">2.0f</span>);</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[directx初第八卷]]></title>
      <url>https://2324268086.github.io/2017/02/01/directx%E5%88%9D%E7%AC%AC%E5%85%AB%E5%8D%B7/</url>
      <content type="html"><![CDATA[<h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><h3 id="创建几何体"><a href="#创建几何体" class="headerlink" title="创建几何体"></a>创建几何体</h3><p><code>通过顶点缓存和索引缓存</code><br><a id="more"></a><br>请看前面的章节</p>
<p><code>通过内置几何体</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ID3DXMesh* mesh;</span><br><span class="line"><span class="comment">//创建立方体（设备指针，宽度，高度，深度，把结果存到网格指针，无三角形索引指针）</span></span><br><span class="line">D3DXCreateBox(g_pd3dDevice, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, &amp;mesh, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//创建茶壶（设备指针，把结果存到网格指针，无三角形索引指针）</span></span><br><span class="line">D3DXCreateTeapot(g_pd3dDevice, &amp;mesh, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//创建柱体（设备指针，z轴负方向半径，z轴正方向半径，高度，柱体外围面数，柱体两端间段数，把结果存到网格指针，无三角形索引指针）</span></span><br><span class="line">D3DXCreateCylinder(g_pd3dDevice, <span class="number">.5</span>f, <span class="number">.5</span>f, <span class="number">2</span>, <span class="number">20</span>, <span class="number">20</span>, &amp;mesh, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//创建圆环体（设备指针，内圈半径，外圈半径，外圈面数，内圈与外圈之间面数，把结果存到网格指针，无三角形索引指针）</span></span><br><span class="line">D3DXCreateTorus(g_pd3dDevice, <span class="number">0.5f</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">20</span>, &amp;mesh, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//创建球面体（设备指针，每条边长度，经线数，纬线数，把结果存到网格指针，无三角形索引指针）</span></span><br><span class="line">D3DXCreateSphere(g_pd3dDevice, <span class="number">1</span>, <span class="number">20</span>, <span class="number">20</span>, &amp;mesh, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//创建2d多边形（设备指针，每条边长度，三角形数，把结果存到网格指针，无三角形索引指针）</span></span><br><span class="line">D3DXCreatePolygon(g_pd3dDevice, <span class="number">2.0</span>, <span class="number">3</span>, &amp;mesh, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//绘制网格</span></span><br><span class="line">mesh-&gt;DrawSubset(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>通过导入模型</code><br>以后再详细说明</p>
<h3 id="设置材质"><a href="#设置材质" class="headerlink" title="设置材质"></a>设置材质</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//填充材质结构</span></span><br><span class="line">D3DMATERIAL9 mtrl;</span><br><span class="line">mtrl.Ambient = (D3DXCOLOR)D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//环境光颜色值</span></span><br><span class="line">mtrl.Diffuse = (D3DXCOLOR)D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//漫反射光颜色值</span></span><br><span class="line">mtrl.Specular = (D3DXCOLOR)D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//镜面反射光颜色值</span></span><br><span class="line">mtrl.Power = <span class="number">2</span>; <span class="comment">//镜面反射指数</span></span><br><span class="line">mtrl.Emissive = (D3DXCOLOR)D3DCOLOR_XRGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//自发光颜色值</span></span><br><span class="line"><span class="comment">//设置材质</span></span><br><span class="line">g_pd3dDevice-&gt;SetMaterial(&amp;mtrl);</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[directx初第七卷]]></title>
      <url>https://2324268086.github.io/2017/01/31/directx%E5%88%9D%E7%AC%AC%E4%B8%83%E5%8D%B7/</url>
      <content type="html"><![CDATA[<h2 id="光照处理"><a href="#光照处理" class="headerlink" title="光照处理"></a>光照处理</h2><h3 id="光照类型"><a href="#光照类型" class="headerlink" title="光照类型"></a>光照类型</h3><p><code>环境光（ambient）</code><br><a id="more"></a><br>环境光就是场景中物体表面产生的反射光的统一光照，环境光没有位置和方向，并且值为常量。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置渲染状态（环境光，颜色）</span></span><br><span class="line">g_pd3dDevice-&gt;SetRenderState(D3DRS_AMBIENT, D3DCOLOR_XRGB(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>));</span><br></pre></td></tr></table></figure></p>
<p><code>漫反射光（diffuse）</code></p>
<p>由光照方向以及顶点法向量计算得到</p>
<p><code>镜面反射光（specular）</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置渲染状态（镜面反射，开启）</span></span><br><span class="line">g_pd3dDevice-&gt;SetRenderState(D3DRS_SPECULARENABLE, TRUE);</span><br></pre></td></tr></table></figure></p>
<p><code>自发光（emissive）</code></p>
<p>通过对物体材质Emissive属性设置来实现的，自发光不会影响到其他物体</p>
<h3 id="光源类型"><a href="#光源类型" class="headerlink" title="光源类型"></a>光源类型</h3><p><code>点光源（point）</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">D3DLIGHT9 <span class="title">InitPointLight</span><span class="params">(D3DXVECTOR3* position, D3DXCOLOR* color)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	D3DLIGHT9 light;</span><br><span class="line">	::ZeroMemory(&amp;light, <span class="keyword">sizeof</span>(light));</span><br><span class="line">	light.Type = D3DLIGHT_POINT; <span class="comment">//类型为点光源</span></span><br><span class="line">	light.Ambient = *color*<span class="number">.6</span>f; <span class="comment">//环境光颜色值</span></span><br><span class="line">	light.Diffuse = *color; <span class="comment">//漫反射颜色值</span></span><br><span class="line">	light.Specular = *color*<span class="number">.6</span>f; <span class="comment">//镜面反射颜色值</span></span><br><span class="line">	light.Position = *position; <span class="comment">//光源位置</span></span><br><span class="line">	light.Range = <span class="number">1000</span>; <span class="comment">//光照范围</span></span><br><span class="line">	light.Attenuation0 = <span class="number">1</span>; <span class="comment">//这三个参数，表示光强随距离衰减的方式</span></span><br><span class="line">	light.Attenuation1 = <span class="number">0</span>;</span><br><span class="line">	light.Attenuation2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> light;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">D3DXVECTOR3 <span class="title">pos</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">D3DXCOLOR color = D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">D3DLIGHT9 point;</span><br><span class="line">point = InitPointLight(&amp;pos, &amp;color);</span><br><span class="line"><span class="comment">//设置光源（选择第一个光源，填充好的灯光类型地址）</span></span><br><span class="line">g_pd3dDevice-&gt;SetLight(<span class="number">0</span>, &amp;point);</span><br><span class="line"><span class="comment">//启用光照（选择第一个光源，开灯）</span></span><br><span class="line">g_pd3dDevice-&gt;LightEnable(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//设置渲染状态（对法线向量进行归一化处理，开启）</span></span><br><span class="line">g_pd3dDevice-&gt;SetRenderState(D3DRS_NORMALIZENORMALS, <span class="literal">true</span>);</span><br><span class="line">g_pd3dDevice-&gt;SetRenderState(D3DRS_SPECULARENABLE, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/directx初第七卷1.PNG" alt=""></p>
<p><code>方向光（directional）</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">D3DLIGHT9 <span class="title">InitDirectionalLight</span><span class="params">(D3DXVECTOR3* direction, D3DXCOLOR* color)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	D3DLIGHT9 light;</span><br><span class="line">	::ZeroMemory(&amp;light, <span class="keyword">sizeof</span>(light));</span><br><span class="line">	light.Type = D3DLIGHT_DIRECTIONAL;</span><br><span class="line">	light.Ambient = *color*<span class="number">.6</span>f;</span><br><span class="line">	light.Diffuse = *color;</span><br><span class="line">	light.Specular = *color*<span class="number">.6</span>f;</span><br><span class="line">	light.Direction = *direction; <span class="comment">//光源光照方向</span></span><br><span class="line">	<span class="keyword">return</span> light;</span><br><span class="line">&#125;</span><br><span class="line">D3DLIGHT9 directional;</span><br><span class="line"><span class="function">D3DXVECTOR3 <span class="title">dir</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">.25</span>f)</span></span>;</span><br><span class="line">D3DXCOLOR color = D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">directional = InitDirectionalLight(&amp;dir, &amp;color);</span><br><span class="line">g_pd3dDevice-&gt;SetLight(<span class="number">0</span>, &amp;directional);</span><br><span class="line">g_pd3dDevice-&gt;LightEnable(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">g_pd3dDevice-&gt;SetRenderState(D3DRS_NORMALIZENORMALS, <span class="literal">true</span>);</span><br><span class="line">g_pd3dDevice-&gt;SetRenderState(D3DRS_SPECULARENABLE, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/directx初第七卷2.PNG" alt=""></p>
<p><code>聚光灯（spot）</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">D3DLIGHT9 <span class="title">InitSpotLight</span><span class="params">(D3DXVECTOR3* position, D3DXVECTOR3* direction, D3DXCOLOR* color)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	D3DLIGHT9 light;</span><br><span class="line">	::ZeroMemory(&amp;light, <span class="keyword">sizeof</span>(light));</span><br><span class="line">	light.Type = D3DLIGHT_SPOT;</span><br><span class="line">	light.Ambient = *color*<span class="number">.0</span>f;</span><br><span class="line">	light.Diffuse = *color;</span><br><span class="line">	light.Specular = *color*<span class="number">.6</span>f;</span><br><span class="line">	light.Position = *position;</span><br><span class="line">	light.Direction = *direction;</span><br><span class="line">	light.Range = <span class="number">1000</span>;</span><br><span class="line">	light.Falloff = <span class="number">1</span>; <span class="comment">//用于聚光灯从内锥形到外锥形的衰减方式 </span></span><br><span class="line">	light.Attenuation0 = <span class="number">1</span>;</span><br><span class="line">	light.Attenuation1 = <span class="number">0</span>;</span><br><span class="line">	light.Attenuation2 = <span class="number">0</span>;</span><br><span class="line">	light.Theta = <span class="number">.4</span>f; <span class="comment">//仅用于聚光灯，内锥形的角度，单位为弧度</span></span><br><span class="line">	light.Phi = <span class="number">.9</span>f; <span class="comment">//仅用于聚光灯，外锥形的角度，单位为弧度</span></span><br><span class="line">	<span class="keyword">return</span> light;</span><br><span class="line">&#125;</span><br><span class="line">D3DLIGHT9 spot;</span><br><span class="line"><span class="function">D3DXVECTOR3 <span class="title">pos</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-5</span>)</span></span>;</span><br><span class="line"><span class="function">D3DXVECTOR3 <span class="title">dir</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">D3DXCOLOR color = White;</span><br><span class="line">spot = InitSpotLight(&amp;pos, &amp;dir, &amp;color);</span><br><span class="line">g_pd3dDevice-&gt;SetLight(<span class="number">0</span>, &amp;spot);</span><br><span class="line">g_pd3dDevice-&gt;LightEnable(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">g_pd3dDevice-&gt;SetRenderState(D3DRS_NORMALIZENORMALS, <span class="literal">true</span>);</span><br><span class="line">g_pd3dDevice-&gt;SetRenderState(D3DRS_SPECULARENABLE, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/directx初第七卷3.PNG" alt=""></p>
<h3 id="没有效果？需要模型和材质才能看得出效果（以后再详细说明）"><a href="#没有效果？需要模型和材质才能看得出效果（以后再详细说明）" class="headerlink" title="没有效果？需要模型和材质才能看得出效果（以后再详细说明）"></a>没有效果？需要模型和材质才能看得出效果（以后再详细说明）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ID3DXMesh* teapot;</span><br><span class="line">D3DXCreateTeapot(g_pd3dDevice, &amp;teapot, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">D3DMATERIAL9 mtrl;</span><br><span class="line">mtrl.Ambient = (D3DXCOLOR)D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">mtrl.Diffuse = (D3DXCOLOR)D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">mtrl.Specular = (D3DXCOLOR)D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">mtrl.Power = <span class="number">2</span>;</span><br><span class="line">mtrl.Emissive = (D3DXCOLOR)D3DCOLOR_XRGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">g_pd3dDevice-&gt;SetMaterial(&amp;mtrl);</span><br><span class="line">teapot-&gt;DrawSubset(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[directx初第六卷]]></title>
      <url>https://2324268086.github.io/2017/01/31/directx%E5%88%9D%E7%AC%AC%E5%85%AD%E5%8D%B7/</url>
      <content type="html"><![CDATA[<h2 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h2><h3 id="世界变换（局部坐标系转换到世界坐标系）"><a href="#世界变换（局部坐标系转换到世界坐标系）" class="headerlink" title="世界变换（局部坐标系转换到世界坐标系）"></a>世界变换（局部坐标系转换到世界坐标系）</h3><p><code>缩放</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D3DXMATRIX scale;</span><br><span class="line"><span class="comment">//缩放矩阵（把生成的缩放矩阵存到矩阵变量中，x，y，z）</span></span><br><span class="line">D3DXMatrixScaling(&amp;scale, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//设置变换（世界矩阵变换类型，和参数1矩阵右乘的矩阵）</span></span><br><span class="line">g_pd3dDevice-&gt;SetTransform(D3DTS_WORLD,&amp;scale);</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><img src="/img/directx初第六卷1.PNG" alt=""></p>
<p><code>旋转</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D3DXMATRIX rotation;</span><br><span class="line"><span class="comment">//角度=45弧度*（π/180）</span></span><br><span class="line"><span class="keyword">float</span> angle = <span class="number">45</span> * (D3DX_PI / <span class="number">180</span>);</span><br><span class="line"><span class="comment">//Y轴旋转矩阵（把生成的旋转矩阵存到矩阵变量中，角度）</span></span><br><span class="line">D3DXMatrixRotationY(&amp;rotation, angle);</span><br><span class="line">g_pd3dDevice-&gt;SetTransform(D3DTS_WORLD, &amp;rotation);</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/directx初第六卷2.PNG" alt=""></p>
<p><code>平移</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D3DXMATRIX trans;</span><br><span class="line"><span class="comment">//平移矩阵（把生成的平移矩阵存到矩阵变量中，x，y，z）</span></span><br><span class="line">D3DXMatrixTranslation(&amp;trans,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">g_pd3dDevice-&gt;SetTransform(D3DTS_WORLD, &amp;trans);</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/directx初第六卷3.PNG" alt=""></p>
<p><code>抱团开雾</code><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D3DXMATRIX world, scale, rotation, trans;</span><br><span class="line">	</span><br><span class="line">D3DXMatrixScaling(&amp;scale, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> angle = <span class="number">45</span> * (D3DX_PI / <span class="number">180</span>);</span><br><span class="line">D3DXMatrixRotationY(&amp;rotation, angle);</span><br><span class="line"><span class="comment">//矩阵相乘（把结果矩阵存到矩阵变量中，左乘矩阵，右乘矩阵），顺序为：1缩2旋3平</span></span><br><span class="line">D3DXMatrixMultiply(&amp;world, &amp;scale, &amp;rotation);</span><br><span class="line"></span><br><span class="line">D3DXMatrixTranslation(&amp;trans, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">D3DXMatrixMultiply(&amp;world, &amp;world, &amp;trans);</span><br><span class="line"></span><br><span class="line">g_pd3dDevice-&gt;SetTransform(D3DTS_WORLD, &amp;world);</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/directx初第六卷4.PNG" alt=""></p>
<h3 id="取景变换（设置摄像机位置）"><a href="#取景变换（设置摄像机位置）" class="headerlink" title="取景变换（设置摄像机位置）"></a>取景变换（设置摄像机位置）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">D3DXVECTOR3 <span class="title">position</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-5</span>)</span></span>;</span><br><span class="line"><span class="function">D3DXVECTOR3 <span class="title">target</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">D3DXVECTOR3 <span class="title">up</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">D3DXMATRIX v;</span><br><span class="line"><span class="comment">//生成取景变换矩阵（把生成的观察矩阵存到矩阵变量中，摄像机在世界坐标系位置，观察点在世界坐标系的位置，摄像机up向量）</span></span><br><span class="line">D3DXMatrixLookAtLH(&amp;v, &amp;position, &amp;target, &amp;up);</span><br><span class="line">g_pd3dDevice-&gt;SetTransform(D3DTS_VIEW, &amp;v);</span><br></pre></td></tr></table></figure>
<h3 id="投影变换（三维物体投影到二维的屏幕上）"><a href="#投影变换（三维物体投影到二维的屏幕上）" class="headerlink" title="投影变换（三维物体投影到二维的屏幕上）"></a>投影变换（三维物体投影到二维的屏幕上）</h3><p><code>视截体</code>：虚拟摄像机与投影窗口组成的三维空间</p>
<p><code>裁剪</code>：位于视截体内的物体会被投影到二维平面，而位于视截体外的物体将不会被显示<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D3DXMATRIX proj;</span><br><span class="line"><span class="comment">//生成视截体（把生成的投影变换矩阵存到矩阵变量中，视域角度（摄像机在y轴的成像角度），宽，高，近裁剪面距（摄像机离最近裁剪平面距离），远裁剪面距）</span></span><br><span class="line">D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI*<span class="number">.5</span>f, (<span class="keyword">float</span>)<span class="number">640</span> / (<span class="keyword">float</span>)<span class="number">480</span>, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">g_pd3dDevice-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);</span><br></pre></td></tr></table></figure></p>
<h3 id="视口变换（设置显示区域）"><a href="#视口变换（设置显示区域）" class="headerlink" title="视口变换（设置显示区域）"></a>视口变换（设置显示区域）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//视口结构体（x，y，宽度，高度，最小深度，最大深度）</span></span><br><span class="line">D3DVIEWPORT9 vp = &#123; <span class="number">30</span>, <span class="number">20</span>, <span class="number">560</span>, <span class="number">400</span>, <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">g_pd3dDevice-&gt;SetViewport(&amp;vp);</span><br></pre></td></tr></table></figure>
<p><img src="/img/directx初第六卷5.PNG" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[directx初第五卷]]></title>
      <url>https://2324268086.github.io/2017/01/30/directx%E5%88%9D%E7%AC%AC%E4%BA%94%E5%8D%B7/</url>
      <content type="html"><![CDATA[<h2 id="索引缓存"><a href="#索引缓存" class="headerlink" title="索引缓存"></a>索引缓存</h2><p>声明变量<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">IDirect3DVertexBuffer9* vb = <span class="number">0</span>;</span><br><span class="line">IDirect3DIndexBuffer9* ib = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>设计顶点结构<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> vertex </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">float</span> _x, _y,_z;</span><br><span class="line">	vertex()&#123;&#125;</span><br><span class="line">	vertex(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span><br><span class="line">	&#123;</span><br><span class="line">		_x = x; _y = y; _z = z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> DWORD fvf;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> DWORD vertex::fvf = D3DFVF_XYZ;</span><br></pre></td></tr></table></figure></p>
<p>创建顶点缓存&amp;索引缓存<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g_pd3dDevice-&gt;CreateVertexBuffer(<span class="number">8</span> * <span class="keyword">sizeof</span>(vertex), D3DUSAGE_WRITEONLY, vertex::fvf, D3DPOOL_MANAGED, &amp;vb, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//创建索引缓存（索引缓存大小，只写，16位索引，由d3d自动选择顶点缓冲区的位置（显存/缓存），把结果存到索引缓存指针，基本为null）</span></span><br><span class="line">g_pd3dDevice-&gt;CreateIndexBuffer(<span class="number">36</span> * <span class="keyword">sizeof</span>(WORD), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_MANAGED, &amp;ib, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>访问和填充顶点缓存&amp;索引缓存<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vertex* vertices;</span><br><span class="line">vb-&gt;Lock(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">void</span>**)&amp;vertices,<span class="number">0</span>);</span><br><span class="line">vertices[<span class="number">0</span>] = vertex&#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">vertices[<span class="number">1</span>] = vertex&#123; <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">vertices[<span class="number">2</span>] = vertex&#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">vertices[<span class="number">3</span>] = vertex&#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">vertices[<span class="number">4</span>] = vertex&#123; <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">vertices[<span class="number">5</span>] = vertex&#123; <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">vertices[<span class="number">6</span>] = vertex&#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">vertices[<span class="number">7</span>] = vertex&#123; <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">vb-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">WORD* indices = <span class="number">0</span>;</span><br><span class="line">ib-&gt;Lock(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">void</span>**)&amp;indices, <span class="number">0</span>);</span><br><span class="line">indices[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">indices[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">indices[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">indices[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">indices[<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">indices[<span class="number">5</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">indices[<span class="number">6</span>] = <span class="number">4</span>;</span><br><span class="line">indices[<span class="number">7</span>] = <span class="number">6</span>;</span><br><span class="line">indices[<span class="number">8</span>] = <span class="number">5</span>;</span><br><span class="line">indices[<span class="number">9</span>] = <span class="number">4</span>;</span><br><span class="line">indices[<span class="number">10</span>] = <span class="number">7</span>;</span><br><span class="line">indices[<span class="number">11</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">indices[<span class="number">12</span>] = <span class="number">4</span>;</span><br><span class="line">indices[<span class="number">13</span>] = <span class="number">5</span>;</span><br><span class="line">indices[<span class="number">14</span>] = <span class="number">1</span>;</span><br><span class="line">indices[<span class="number">15</span>] = <span class="number">4</span>;</span><br><span class="line">indices[<span class="number">16</span>] = <span class="number">1</span>;</span><br><span class="line">indices[<span class="number">17</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">indices[<span class="number">18</span>] = <span class="number">3</span>;</span><br><span class="line">indices[<span class="number">19</span>] = <span class="number">2</span>;</span><br><span class="line">indices[<span class="number">20</span>] = <span class="number">6</span>;</span><br><span class="line">indices[<span class="number">21</span>] = <span class="number">3</span>;</span><br><span class="line">indices[<span class="number">22</span>] = <span class="number">6</span>;</span><br><span class="line">indices[<span class="number">23</span>] = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">indices[<span class="number">24</span>] = <span class="number">1</span>;</span><br><span class="line">indices[<span class="number">25</span>] = <span class="number">5</span>;</span><br><span class="line">indices[<span class="number">26</span>] = <span class="number">6</span>;</span><br><span class="line">indices[<span class="number">27</span>] = <span class="number">1</span>;</span><br><span class="line">indices[<span class="number">28</span>] = <span class="number">6</span>;</span><br><span class="line">indices[<span class="number">29</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">indices[<span class="number">30</span>] = <span class="number">4</span>;</span><br><span class="line">indices[<span class="number">31</span>] = <span class="number">0</span>;</span><br><span class="line">indices[<span class="number">32</span>] = <span class="number">3</span>;</span><br><span class="line">indices[<span class="number">33</span>] = <span class="number">4</span>;</span><br><span class="line">indices[<span class="number">34</span>] = <span class="number">3</span>;</span><br><span class="line">indices[<span class="number">35</span>] = <span class="number">7</span>;</span><br><span class="line">ib-&gt;Unlock();</span><br></pre></td></tr></table></figure></p>
<p>绘制顶点&amp;索引<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g_pd3dDevice-&gt;SetStreamSource(<span class="number">0</span>, vb, <span class="number">0</span>, <span class="keyword">sizeof</span>(vertex));</span><br><span class="line"><span class="comment">//设置索引缓存</span></span><br><span class="line">g_pd3dDevice-&gt;SetIndices(ib);</span><br><span class="line">g_pd3dDevice-&gt;SetFVF(vertex::fvf);</span><br><span class="line"><span class="comment">//图形索引绘制（三角形列模式，从索引0开始读取索引缓存，索引中最小值为0，为8个顶点做索引，从索引0开始绘制图元，绘制12个图元）</span></span><br><span class="line">g_pd3dDevice-&gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST, <span class="number">0</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure></p>
<p>目前写完可是运行看不见效果？加上下面代码（以后再详细说明）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">D3DXVECTOR3 <span class="title">position</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-5</span>)</span></span>;</span><br><span class="line"><span class="function">D3DXVECTOR3 <span class="title">target</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">D3DXVECTOR3 <span class="title">up</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">D3DXMATRIX v;</span><br><span class="line">D3DXMatrixLookAtLH(&amp;v, &amp;position, &amp;target, &amp;up);</span><br><span class="line">g_pd3dDevice-&gt;SetTransform(D3DTS_VIEW, &amp;v);</span><br><span class="line"></span><br><span class="line">D3DXMATRIX proj;</span><br><span class="line">D3DXMatrixPerspectiveFovLH(&amp;proj, D3DX_PI*<span class="number">.5</span>f, (<span class="keyword">float</span>)<span class="number">640</span> / (<span class="keyword">float</span>)<span class="number">480</span>, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">g_pd3dDevice-&gt;SetTransform(D3DTS_PROJECTION, &amp;proj);</span><br><span class="line">g_pd3dDevice-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="/img/directx初第五卷.PNG" alt=""></p>
<blockquote>
<p>注：渲染效果不一样？<br>加上以下代码（以后再详细说明）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g_pd3dDevice-&gt;SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);</span><br></pre></td></tr></table></figure></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[directx初第四卷]]></title>
      <url>https://2324268086.github.io/2017/01/30/directx%E5%88%9D%E7%AC%AC%E5%9B%9B%E5%8D%B7/</url>
      <content type="html"><![CDATA[<h2 id="顶点缓存"><a href="#顶点缓存" class="headerlink" title="顶点缓存"></a>顶点缓存</h2><p>声明变量<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LPDIRECT3DVERTEXBUFFER9 g_vertexBuffer = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>设计顶点结构<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> d3dVertex</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">float</span> x, y, z, rhw; <span class="comment">//经过变换的坐标</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> color; <span class="comment">//颜色</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//（FVF）灵活的顶点格式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> d3dfvf_vertex (D3DFVF_XYZRHW | D3DFVF_DIFFUSE) <span class="comment">//标识为：包含经坐标变换的顶点坐标值|包含漫反射颜色值</span></span></span><br></pre></td></tr></table></figure></p>
<p>填充顶点结构<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置d3d格式的白色颜色</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> col = D3DCOLOR_XRGB(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line"><span class="comment">//写入数组</span></span><br><span class="line">d3dVertex objData[] =</span><br><span class="line">&#123;</span><br><span class="line">	&#123; <span class="number">420</span>, <span class="number">150</span>, <span class="number">0.5f</span>, <span class="number">1</span>, col &#125;,</span><br><span class="line">	&#123; <span class="number">420</span>, <span class="number">350</span>, <span class="number">0.5f</span>, <span class="number">1</span>, col &#125;,</span><br><span class="line">	&#123; <span class="number">220</span>, <span class="number">150</span>, <span class="number">0.5f</span>, <span class="number">1</span>, col &#125;,</span><br><span class="line">	&#123; <span class="number">220</span>, <span class="number">350</span>, <span class="number">0.5f</span>, <span class="number">1</span>, col &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>创建顶点缓存<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建顶点缓存（顶点缓存的大小，无附加属性，顶点格式，默认（顶点缓存存在显存中），把结果存到顶点缓存指针，基本为null）</span></span><br><span class="line"><span class="keyword">if</span> (FAILED(g_pd3dDevice-&gt;CreateVertexBuffer(<span class="keyword">sizeof</span>(objData),<span class="number">0</span>,d3dfvf_vertex,D3DPOOL_DEFAULT,&amp;g_vertexBuffer,<span class="literal">NULL</span>)))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>访问顶点缓存<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptr;</span><br><span class="line"><span class="comment">//加锁处理（内存起始位置到加锁位置的偏移量，加锁区域大小，加锁对象指针，无加锁方式）</span></span><br><span class="line"><span class="keyword">if</span> (FAILED(g_vertexBuffer-&gt;Lock(<span class="number">0</span>, <span class="keyword">sizeof</span>(objData), (<span class="keyword">void</span>**)&amp;ptr, <span class="number">0</span>)))</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line"><span class="comment">//将objData内容复制到ptr地址</span></span><br><span class="line"><span class="built_in">memcpy</span>(ptr, objData, <span class="keyword">sizeof</span>(objData));</span><br><span class="line"><span class="comment">//解锁处理</span></span><br><span class="line">g_vertexBuffer-&gt;Unlock();</span><br></pre></td></tr></table></figure></p>
<p>绘制顶点<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顶点缓存关联渲染流水线（不指定与该顶点缓存相关联的数据流，包含顶点数据的顶点缓存指针，无偏移量，顶点结构大小）</span></span><br><span class="line">g_pd3dDevice-&gt;SetStreamSource(<span class="number">0</span>, g_vertexBuffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(d3dVertex));</span><br><span class="line"><span class="comment">//指定灵活顶点格式</span></span><br><span class="line">g_pd3dDevice-&gt;SetFVF(d3dfvf_vertex);</span><br><span class="line"><span class="comment">//图形绘制（线列模式，从位置0开始读取顶点缓存，绘制2个图元）</span></span><br><span class="line">g_pd3dDevice-&gt;DrawPrimitive(D3DPT_LINELIST, <span class="number">0</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="/img/directx初第四卷.PNG" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[directx初第三卷]]></title>
      <url>https://2324268086.github.io/2017/01/30/directx%E5%88%9D%E7%AC%AC%E4%B8%89%E5%8D%B7/</url>
      <content type="html"><![CDATA[<h3 id="固定功能渲染流水线"><a href="#固定功能渲染流水线" class="headerlink" title="固定功能渲染流水线"></a>固定功能渲染流水线</h3><p><code>顶点处理</code>：非T&amp;L顶点（未经过坐标变换和光照处理的顶点）-&gt;[<strong>第一阶段</strong>]坐标变换和光照处理（世界变换-&gt;取景变换-&gt;光照处理-&gt;投影变换-&gt;视口变换）<br><code>光栅化计算</code>：T&amp;L顶点（经过坐标变换和光照处理的顶点）-&gt;[<strong>第二阶段</strong>]光栅化处理（纹理映射-&gt;图元处理-&gt;内部函数改变渲染状态）<br><code>像素处理</code>：片段处理器-&gt;显存帧缓冲-&gt;显示<br><a id="more"></a></p>
<h3 id="可编程渲染流水线"><a href="#可编程渲染流水线" class="headerlink" title="可编程渲染流水线"></a>可编程渲染流水线</h3><p><code>镶嵌处理</code>：顶点-&gt;镶嵌器<br><code>顶点处理</code>：变换与光照+顶点着色器-&gt;剔除（背面剔除）-&gt;剪裁（用户剪裁平面-&gt;截头体剪裁）-&gt;齐次除法-&gt;视口映射<br><code>光栅化计算</code>：三角形设置<br><code>像素处理</code>：多重纹理贴图+像素着色器-&gt;测试（剪裁测试-&gt;Alpha测试-&gt;深度测试+模版测试）-&gt;Alpha混合-&gt;浓淡处理-&gt;通道掩码-&gt;显存帧缓冲-&gt;显示</p>
<p>其中，顶点着色器模块，像素着色器模块为可编程模块<br>他们的着色器单元（四元组结构）分别为：<br><code>Vertex Shader</code>：float4(X,Y,Z,W)<br><code>Pixel Shader</code>：float4(R,G,B,A)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[directx初第二卷]]></title>
      <url>https://2324268086.github.io/2017/01/29/directx%E5%88%9D%E7%AC%AC%E4%BA%8C%E5%8D%B7/</url>
      <content type="html"><![CDATA[<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>添加头文件<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;d3dx9.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>声明变量<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LPDIRECT3D9 g_pD3D = <span class="literal">NULL</span>;</span><br><span class="line">LPDIRECT3DDEVICE9 g_pd3dDevice = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<p>关键代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建directx接口</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == (g_pD3D = Direct3DCreate9(D3D_SDK_VERSION)))</span><br><span class="line">	<span class="keyword">return</span> E_FAIL;</span><br><span class="line"></span><br><span class="line"><span class="comment">//校验硬件顶点运算</span></span><br><span class="line">D3DCAPS9 caps; <span class="keyword">int</span> vp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//获取设备性能参数（默认（当前使用的显卡），硬件（抽象层）设备类型，把结果存到设备信息指针）</span></span><br><span class="line"><span class="keyword">if</span> (FAILED(g_pD3D-&gt;GetDeviceCaps(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, &amp;caps)))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> E_FAIL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (caps.DevCaps &amp; D3DDEVCAPS_HWTRANSFORMANDLIGHT)</span><br><span class="line">	vp = D3DCREATE_HARDWARE_VERTEXPROCESSING; <span class="comment">//支持硬件顶点运算</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	vp = D3DCREATE_SOFTWARE_VERTEXPROCESSING; <span class="comment">//不支持（则采用软件顶点运算）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//填充D3DPRESENT_PARAMETER结构</span></span><br><span class="line">D3DPRESENT_PARAMETERS d3dpp;</span><br><span class="line"><span class="comment">//将指定内存清零（内存地址，内存大小）</span></span><br><span class="line">ZeroMemory(&amp;d3dpp, <span class="keyword">sizeof</span>(d3dpp));</span><br><span class="line">d3dpp.Windowed = TRUE; <span class="comment">//指定以Windows窗体形式显示</span></span><br><span class="line">d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD; <span class="comment">//当前屏幕绘制后它将自动从内存中删除  </span></span><br><span class="line">d3dpp.BackBufferFormat = D3DFMT_UNKNOWN; <span class="comment">//后台缓冲区像素格式为当前使用的显卡的像素格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建directx设备接口（默认（当前使用的显卡），硬件（抽象层）设备类型，当前窗口句柄，设备行为标识，已填充的结构，把结果存到设备指针）</span></span><br><span class="line"><span class="keyword">if</span> (FAILED(g_pD3D-&gt;CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWnd,</span><br><span class="line">	vp,</span><br><span class="line">	&amp;d3dpp, &amp;g_pd3dDevice)))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> E_FAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>关键代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> != g_pd3dDevice)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//清空后台缓冲区（矩形数组中矩形的数量为0，无矩形数组（清空区域）指针，标识为颜色缓冲区，蓝色，像素深度值为1，像素模版值为0）</span></span><br><span class="line">	g_pd3dDevice-&gt;Clear(<span class="number">0</span>, <span class="literal">NULL</span>, D3DCLEAR_TARGET, D3DCOLOR_XRGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1.0f</span>, <span class="number">0</span>); </span><br><span class="line">	<span class="comment">//开始绘制</span></span><br><span class="line">	<span class="keyword">if</span> (SUCCEEDED(g_pd3dDevice-&gt;BeginScene()))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//绘制</span></span><br><span class="line">		....</span><br><span class="line">		<span class="comment">//结束绘制</span></span><br><span class="line">		g_pd3dDevice-&gt;EndScene();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//翻转显示（无复制源矩形区域的指针，无复制目标矩形区域的指针，无当前绘制的窗口句柄，无最小更新区域的指针）</span></span><br><span class="line">	g_pd3dDevice-&gt;Present(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//后台渲染的东西翻转到前台</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[directx初第一卷]]></title>
      <url>https://2324268086.github.io/2017/01/29/directx%E5%88%9D%E7%AC%AC%E4%B8%80%E5%8D%B7/</url>
      <content type="html"><![CDATA[<h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>下载Directx SDK(directx sdk june10就可以了)，在VS(vs2013差不多了)中新建win32空项目，<br>然后在视图-&gt;属性管理器找到 Debug|Win32-&gt;Microsoft.Cpp.Win32.user，<br>双击，选择vc++目录，设置包含目录和库目录为刚刚下的directx sdk目录中include，lib\x86 的路径<br><a id="more"></a><br>选择链接器，设置附加依赖项，粘贴以下代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dxerr.lib</span><br><span class="line">dxguid.lib</span><br><span class="line">d3dx9d.lib</span><br><span class="line">d3dx10d.lib</span><br><span class="line">d3d9.lib</span><br><span class="line">winmm.lib</span><br><span class="line">comctl32.lib</span><br></pre></td></tr></table></figure></p>
<p>下载番茄插件(VA)，同样加入dx sdk的include路径</p>
<p>配置完成了! 不在累赘</p>
<h3 id="Directx渲染体系"><a href="#Directx渲染体系" class="headerlink" title="Directx渲染体系"></a>Directx渲染体系</h3><p><code>老版</code>：固定功能流水线 使用directx内部封装的函数改变渲染状态<br><code>新版</code>：可编程渲染流水线 shader，使用hlsl(支持cg函数)或者shader汇编代码(被hlsl代替)来灵活的渲染</p>
<h3 id="Directx程序流程"><a href="#Directx程序流程" class="headerlink" title="Directx程序流程"></a>Directx程序流程</h3><p>创建win32窗口-&gt;<strong>初始化</strong>（创建directx接口-&gt;校验硬件顶点运算-&gt;填充D3DPRESENT_PARAMETER结构-&gt;创建directx设备接口）<br>中间-&gt;场景布置<br>win32消息循环-&gt;<strong>渲染</strong>（清空缓存-&gt;开始绘制-&gt;绘制-&gt;结束绘制-&gt;翻转显示）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[directx数学基础2]]></title>
      <url>https://2324268086.github.io/2017/01/28/directx%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%802/</url>
      <content type="html"><![CDATA[<p><code>向量（vector）</code>：在游戏中通常表示位置，移位，方向，速度和作用力（请看directx数学基础1）<br><code>矩阵（matrix）</code>：在游戏中提供高效的变换方式，几何变换与坐标变换</p>
<h2 id="矩阵（矩形实数数组）"><a href="#矩阵（矩形实数数组）" class="headerlink" title="矩阵（矩形实数数组）"></a>矩阵（矩形实数数组）</h2><a id="more"></a>
<h3 id="矩阵乘法（a中的行向量的维数必须与b中的列向量的维数相同）"><a href="#矩阵乘法（a中的行向量的维数必须与b中的列向量的维数相同）" class="headerlink" title="矩阵乘法（a中的行向量的维数必须与b中的列向量的维数相同）"></a>矩阵乘法（a中的行向量的维数必须与b中的列向量的维数相同）</h3><p>例如： <img src="/img/directx数学基础_13.png" alt=""></p>
<h3 id="转置矩阵（transpose：-对一个矩阵的行和列进行互换）"><a href="#转置矩阵（transpose：-对一个矩阵的行和列进行互换）" class="headerlink" title="转置矩阵（transpose： 对一个矩阵的行和列进行互换）"></a>转置矩阵（transpose： 对一个矩阵的行和列进行互换）</h3><p>标记为T</p>
<h3 id="单位矩阵（identity：-除了对角线上的元素为1外，其他元素均为0）"><a href="#单位矩阵（identity：-除了对角线上的元素为1外，其他元素均为0）" class="headerlink" title="单位矩阵（identity： 除了对角线上的元素为1外，其他元素均为0）"></a>单位矩阵（identity： 除了对角线上的元素为1外，其他元素均为0）</h3><p>单位矩阵相当于1 <img src="/img/directx数学基础_14.png" alt=""></p>
<h3 id="逆矩阵（inverse：-乘法的逆运算（矩阵除法运算））"><a href="#逆矩阵（inverse：-乘法的逆运算（矩阵除法运算））" class="headerlink" title="逆矩阵（inverse： 乘法的逆运算（矩阵除法运算））"></a>逆矩阵（inverse： 乘法的逆运算（矩阵除法运算））</h3><p><code>性质</code>： <img src="/img/directx数学基础_15.png" alt=""></p>
<h3 id="基本变换（4x4矩阵与向量-矩阵乘积来描述变换）"><a href="#基本变换（4x4矩阵与向量-矩阵乘积来描述变换）" class="headerlink" title="基本变换（4x4矩阵与向量-矩阵乘积来描述变换）"></a>基本变换（4x4矩阵与向量-矩阵乘积来描述变换）</h3><p><code>齐次坐标(homogeneous coordinate)</code>： 用于表示3D向量或点的四元组<br>通过它的第4个坐标分量w（控制平移）来判断：<br><img src="/img/directx数学基础_16.png" alt=""></p>
<p><code>缩放</code>：<br><img src="/img/directx数学基础_17.png" alt=""> <img src="/img/directx数学基础_18.png" alt=""><br>例子：<br>假设我们通过一个最小点(−4,−4,0)和一个最大点(4,4,0)来定义一个正方形，我们希望<br>将正方形沿 x 轴缩小 0.5 倍，沿 y 轴放大 2.0 倍，z 轴保持不变则对应的缩放矩阵为：<br><img src="/img/directx数学基础_19.png" alt=""><br>再对正方形进行缩放（变换），将正方形的两个点与该矩阵相乘<br><img src="/img/directx数学基础_20.png" alt=""><br>结果<br><img src="/img/directx数学基础_21.png" alt=""></p>
<p><code>旋转</code>：<br>绕n（x,y,z）轴旋转的’万能’旋转矩阵<br><img src="/img/directx数学基础_22.png" alt=""></p>
<p><code>正交矩阵(orthogonal matrix)</code>: 行向量都是相互垂直且为单位长度<br><code>性质</code>：<br>它的逆矩阵与它的转置矩阵相等 <img src="/img/directx数学基础_23.png" alt=""></p>
<p>绕x，y，z轴（n=（1,0,0） n=（0,1,0） n=（0,0,1））旋转的矩阵<br><img src="/img/directx数学基础_24.png" alt=""></p>
<p>例子：<br>假设我们通过一个最小点(−1,0,−1)和一个最大点(1,0,1)来定义一个正方形。让正方形<br>绕着 y 轴的顺时针方向旋转−30º（即，逆时针方向旋转 30º）。则y轴旋转矩阵为：<br><img src="/img/directx数学基础_25.png" alt=""><br>再对正方形进行旋转（变换），将正方形的两个点与该矩阵相乘：<br><img src="/img/directx数学基础_26.png" alt=""><br>结果<br><img src="/img/directx数学基础_27.png" alt=""></p>
<p><code>平移</code>：<br><img src="/img/directx数学基础_28.png" alt=""><br>平移矩阵的逆矩阵如下：<br><img src="/img/directx数学基础_29.png" alt=""><br>例子：<br>假设我们通过一个最小点(−8,2,0)和一个最大点(−2,8,0)来定义一个正方形。让正方形<br>沿x轴平移12，沿y轴平移−10，z轴保持不变。则对应的平移矩阵如下：<br><img src="/img/directx数学基础_30.png" alt=""><br>再对正方形进行平移（变换），将正方形的两个点与该矩阵相乘：<br><img src="/img/directx数学基础_31.png" alt=""><br>结果<br><img src="/img/directx数学基础_32.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[directx数学基础1]]></title>
      <url>https://2324268086.github.io/2017/01/28/directx%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p><code>向量（vector）</code>：在游戏中通常表示位置，移位，方向，速度和作用力<br><code>矩阵（matrix）</code>：在游戏中提供高效的变换方式，几何变换与坐标变换（请看directx数学基础2）</p>
<h2 id="向量（同具有大小和方向的物理量）"><a href="#向量（同具有大小和方向的物理量）" class="headerlink" title="向量（同具有大小和方向的物理量）"></a>向量（同具有大小和方向的物理量）</h2><a id="more"></a>
<h3 id="坐标系（directx为左手坐标系）"><a href="#坐标系（directx为左手坐标系）" class="headerlink" title="坐标系（directx为左手坐标系）"></a>坐标系（directx为左手坐标系）</h3><p><img src="/img/directx数学基础_1.png" alt=""><br>看上去就像图中z向量相反</p>
<h3 id="向量长度（length）"><a href="#向量长度（length）" class="headerlink" title="向量长度（length）"></a>向量长度（length）</h3><p><code>几何学</code>： 有向线段的长度<br><img src="/img/directx数学基础_2.png" alt=""></p>
<p><code>代数方式</code>： 毕达哥拉斯定理（’不规则’勾股定理）<br><img src="/img/directx数学基础_3.png" alt=""></p>
<h3 id="单位向量（normalize：-不关心向量的长度，只希望用向量来表示一个单纯的方向）"><a href="#单位向量（normalize：-不关心向量的长度，只希望用向量来表示一个单纯的方向）" class="headerlink" title="单位向量（normalize： 不关心向量的长度，只希望用向量来表示一个单纯的方向）"></a>单位向量（normalize： 不关心向量的长度，只希望用向量来表示一个单纯的方向）</h3><p><code>进行规范化处理</code>： <img src="/img/directx数学基础_4.png" alt=""></p>
<p>验证是否为单位向量？只要计算单位向量u的长度就行<br><img src="/img/directx数学基础_5.png" alt=""></p>
<h3 id="点积（dot：-两个向量对应分量的乘积之和）"><a href="#点积（dot：-两个向量对应分量的乘积之和）" class="headerlink" title="点积（dot： 两个向量对应分量的乘积之和）"></a>点积（dot： 两个向量对应分量的乘积之和）</h3><p><code>代数方式</code>： <img src="/img/directx数学基础_6.png" alt=""></p>
<p><code>余弦定理</code>： <img src="/img/directx数学基础_7.png" alt=""><br>结果代入cosx的反函数（acos）即可算出度数，</p>
<p>例如： <img src="/img/directx数学基础_9.png" alt=""></p>
<p><code>几何性质</code>：<br><img src="/img/directx数学基础_8.png" alt=""></p>
<h3 id="叉积（cross：-两个3D向量计算叉积，得到垂直于两个向量的第3个向量-）"><a href="#叉积（cross：-两个3D向量计算叉积，得到垂直于两个向量的第3个向量-）" class="headerlink" title="叉积（cross： 两个3D向量计算叉积，得到垂直于两个向量的第3个向量 ）"></a>叉积（cross： 两个3D向量计算叉积，得到垂直于两个向量的第3个向量 ）</h3><p><code>代数方式</code>： <img src="/img/directx数学基础_10.png" alt=""><br>例如： <img src="/img/directx数学基础_11.png" alt=""></p>
<p><code>正弦定理</code>： <img src="/img/directx数学基础_12.png" alt=""><br>同理结果代入asin即可算出度数，</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[directx前言]]></title>
      <url>https://2324268086.github.io/2017/01/28/directx%E5%89%8D%E8%A8%80/</url>
      <content type="html"><![CDATA[<h4 id="说在前面的话"><a href="#说在前面的话" class="headerlink" title="说在前面的话"></a>说在前面的话</h4><h3 id="为什么学directx？"><a href="#为什么学directx？" class="headerlink" title="为什么学directx？"></a>为什么学directx？</h3><p>原因很简单：对游戏开发的热爱，是游戏开发者必学的一门功课<br><a id="more"></a></p>
<h3 id="为什么选择directx？"><a href="#为什么选择directx？" class="headerlink" title="为什么选择directx？"></a>为什么选择directx？</h3><p>跟directx相比有opengl，还有gdi等，虽然directx不支持跨平台，但是实际开发或者个人游戏也好，用unity之类的引擎解决就好，<br>directx其他方面还是远超opengl，文档也很多。至于gdi，，gdi的性能就是很大的瓶颈，directx直接基于com的效率高的不要不要<br>的，这也是为什么大多游戏引擎都是基于directx或opengl（特例）</p>
<h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><p>龙书d9 d10 d11（只有英文版）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>https://2324268086.github.io/2017/01/26/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to the xiaojian of the home page</p>
<h2 id="欢迎来到小贱的主页"><a href="#欢迎来到小贱的主页" class="headerlink" title="欢迎来到小贱的主页"></a>欢迎来到小贱的主页</h2>]]></content>
    </entry>
    
  
  
</search>
